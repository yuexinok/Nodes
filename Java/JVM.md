# JVM

Java Virtual Machine

OpenJDK,AlibabJDK(AJDK)

## 字节码：

| JVM字节码                   | 注解                         |
| --------------------------- | ---------------------------- |
| ILOAD                       | 将int类型局部变量压入栈      |
| ALOAD                       | 将对象的引用的局部变量压入栈 |
| ISTORE,ASTORE               | 从操作栈顶存储局部变量表     |
| ICONST,BIPUSH,SIPUSH,LDC    | 将常量加载到操作栈顶         |
| IADD,IMUL                   | 运算指令                     |
| 12L,D2F                     | 类型转换指令                 |
| NEW,NEWARRAY                | 对象创建                     |
| GETFIELD,PUTFIELD,GETSTATIC | 访问属性                     |
| INSTANCEOF,CHECKCAST        | 检查实例类型指令             |
| POP                         | 出栈操作                     |
| DUP                         | 复制栈顶元素并压入栈         |
| INVOKEVIRTUAL               | 调用对象的实例方法           |
| INVOKEPECIAL                | 调用实例初始化方法，私有方法 |
| INVOKESTATIC                | 调用类静态方法               |
| RETRUEN                     | 返回void的类型               |
| ACC_SYNCHRONIZED，          | 同步方法标志                 |
| MONTITORENTER,MONITOREXIT   |                              |
|                             |                              |
|                             |                              |

字节码执行方式：

1）解释执行。

2）JIT编译执行。

3）JIT编译与解释混合执行（主流）

## 类加载：

### 双亲委派模型：

1）如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。

2）每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。

3）只有当父加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。

注：user ClassLoader -> **Application ClassLoader**（CLASSPATH） -> **Platform ClassLoader**（jre/lib/ext/*.jar等） -> **Bootstrap ClassLoader**（jre/lib/rt.jar等）

**对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性**，每一个类加载器，都拥有一个独立的类名称空间。因此，使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处：**类随着它的类加载器一起具备了一种带有优先级的层次关系**。

例如类`java.lang.Object`，它由启动类加载器加载。双亲委派模型保证任何类加载器收到的对`java.lang.Object`的加载请求，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此**Object类在程序的各种类加载器环境中都是同一个类**。

相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并用自定义的类加载器加载，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。

### 类加载过程

任何程序都需要加载到内存中才能与CPU进行交流。字节码 .class 文件同样需要家长到内存中，才可以实例化类。ClassLoader 就是提前加载 .class 文件到内存中

过程： 加载、链接、初始化

加载： 读取类文件产生的二进制流，并转为特定的数据结构，初步校验cafe babe 魔法值，常量池、文件长度、是否有父类等，然后创建对应类的实例
链接包括验证、准备、解析三个过程。验证是更详细的校验，比如final 是否合规，类型是否正确、静态变量是否合理等；准备结果是为静态变量分配内存，并设定默认值，解析类和方法确保类与类之间的相互引用正确性，完成内存结构布局
初始化结果，执行类构造器方法，如果赋值运算是通过其他类的静态方法来完成的，那么会马上解析另一个类，在虚拟机栈中执行完毕后通过返回值进行赋值

## JVM内存：

![](./images/jvm.png)

### Heap区：

1）Heap去是OOM故障的主要发源地，它存储了几乎所有的实例对象。堆由垃圾收集器回收。堆区由各子线程共享使用。通过**-Xms**256M **-Xmx**1024控制。设置成一样，避免GC后调整堆大小时带来额外压力。

2）分为**新生代**和**老年代**，其中新生代=**1个Eden区+2个Survivor区**(S0,S1)

3）如果老年代也放不下，就会产生FGC,可以通过设置-XX:+HeapDumpOnOutOfMemoryError，让jvm在遇到OOM异常的时候能够输出堆栈信息。

![](images/jvm1.png)

### Metaspace元空间：

元空间的前身是Perm区（被称为永久代），在JDK7 及之前的版本中才有Perm，现在的版本使用了Metaspace。因为Perm 在某些场景下，如果动态加载类过多，容易产生Perm 区的OOM（为了解决需要设定参数 -XX：MaxPermSize = 1280m），如果部署到新机器上，往往会因为JVM 参数没有修改导致故障再现，不熟悉此应用的人很难排查。所以，元空间就诞生了。元空间在本地内存中分配

OutOfMemoeryError:PermGenspace

### JVM Stack （虚拟机栈)：

栈的特性是先进后出的数据结构，JVM 是基于栈结构的运行环境。JVM 中的虚拟机栈是描述Java方法执行的内存区域，它是线程私有的。栈中的元素用于支持虚拟机进行方法调用，每个方法从开始调用到执行完成的过程。就是栈帧从入栈到出栈的过程。活动线程中只有位于栈顶的帧才是有效的，称为当前栈帧。正在执行的方法称为当前方法。

虚拟机栈通过压栈和出栈的方式，对每个方法对应的活动栈帧进行运算处理，方法正常执行结束，肯定会跳转到另一个栈帧上。在执行过程中，如果出现异常，会进行异常回溯，返回地址通过异常处理表确定。

**局部变量表：** 存放方法参数和局部变量的区域
**操作栈 ：** 一个初始状态为空的桶式结构栈。在方法执行过程中，会有各种指令往栈中写入和提取信息。
**动态连接**：每一个栈帧包含一个常量池中对当前方法的引用，目的是支持方法调用过程的动态连接
**方法返回地址：** 方法执行有两种退出情况： 1. 正常退出。2.异常退出。 无论何种退出情况都将返回到方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧。

### 本地方法栈：

Native Method Stack 在JVM内存布局中，也是线程对象私有的。被称为Native 方法服务，线程开始调用本地方法时，会进入一个不再受JVM约束的世界。本地方法可以通过JNI来访问虚拟机运行时的数据区，甚至可以调用寄存器，具有和JVM相同的能力和权限。

### 程序计数寄存器：

每一个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器用来存放执行指令的偏移量和行号指示器，程序的执行或者恢复都要依赖程序计数器。程序计数器在各线程之间互不影响，此区域不会发生内存溢出异常。

从线程共享的角度来看，堆空间和元空间都所有线程共享的，而虚拟机栈和本地方法栈，程序计数器是线程内部私有的。
![](images/jvm2.png)

### 对象实例化：

NEW->DUP->INVOKESPECIAL

1）**确认类元信息是否存在**。当JVM接受到new指令时，首先在metaspace 内**检查需要创建的类元信息是否存在**。若不存在，那么在双亲委派模式下，使用当前类加载器以ClassLoader +包名+类名为key 进行查找对应的.class 文件，如果没有找到文件，则抛出ClassNotFoundException 异常，如果找到，则进行类加载并生成对应的Class 类对象。
2）**分配对象内存**。首先计算对象占用空间大小，如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小，接着在堆中划分一块内存给新对象。在分配内存空间时，需要进行同步操作，比如采用CAS失败重试，区域加锁等方式保证分配操作的原子性。
3）**设定默认值**。成员变量值都需要设定默认值，即各种不同形式的零值。
4）**设置对象头**。设置新对象的哈希码，GC信息，锁信息，对象所属的类元信息等。这个过程的具体设置方式取决JVM实现。
5）**执行init 方法**。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。

#### 设置对象头

I ）对象头（Object Header )
对象头占用12 个字节，存储内容包括对象标记（markOop ）和类元信息（klassOop ）。
对象标记存储对象本身运行时的数据，如哈希码、GC 标记、锁信息、线程关联信息等，
这部分数据在64 位NM 上占用8 个字节，称为"Mark word",为了存储更多的状
态言息,对象标记的存储恪式是非固定的（具休与JVM 的实现有关）。类元信患、存
储的是对象指向它的类元数据（即Kl ass ）的首地址’占用4 个字节，与refvar 开销一致。
( 2 ）实例数据（Instance Data )
存储本类对象的实例成员变量和所有可见的父类成员变量。如Integer 的实例
成员只有一个private int value ，占用4 个字节，所以加上对象头为16 个字节
( 3 ）对齐填充（Padding )
对象的存储空间分配单位是8 个字节，如果一个占用大小为16 个字节的对象，
增加一个成员变量byte 类型，此时需要占用17 个字节，但是也会分配24 个字节进
行对齐填充操作。

![](./images/object1.png)

#### 垃圾回收：

Serial,CMS,G1主要三种垃圾回收器**-XX:UseG1GC**。

Java 会对内存进行自动分配与回收管理，使上层业务更加安全，方便地使用内存实现程序逻辑。GC 主要目的是清除不再使用的对象，自动释放内存。

- 标记-清除
- 复制
- 标记-整理
- 区分新老年代（分代收集）

