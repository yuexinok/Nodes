# 分布式锁实现方式

https://blog.csdn.net/wuzhiwei549/article/details/80692278

## redis分布式锁

> 互斥性，在任意时刻，只有一个客户端能持有锁。
>
> 不会发生死锁，即客户端没有主动解锁，也可以通过过期解锁
>
> 具有容错性，只要redis节点正常运行，客户端就可以加锁和解锁
>
> 加锁和解锁需要是同一客户端

https://redis.io/commands/setnx

### setnx  key value

key不存在，则设置key的值为value,返回1；若key存在，则不处理返回0

setnx()方法作用就是SET IF NOT EXIST

```shell
redis> EXISTS job                # job 不存在
(integer) 0
redis> SETNX job "programmer"    # job 设置成功
(integer) 1
redis> SETNX job "code-farmer"   # 尝试覆盖 job ，失败
(integer) 0
redis> GET job                   # 没有被覆盖
"programmer"
```

注：SET key value[expiration EX seconds|PX milliseconds] [NX|XX] 可以复用使用

- `EX` *seconds* -- Set the specified expire time, in seconds.
- `PX` *milliseconds* -- Set the specified expire time, in milliseconds.
- `NX` -- Only set the key if it does not already exist.
- `XX` -- Only set the key if it already exist.

```java
jedirs.set(key,value,"NX","PX",100L);
```

为什么使用该命令，而不是其他命令？重点是需要他的判断性，**即不存在才设置，存在不设置**。其次是他的设置性，如set拥有设置，但是无判断，exist拥有判断没有设置。

```java
public class RedisTool {

    private static final String LOCK_SUCCESS = "OK";
    private static final String SET_IF_NOT_EXIST = "NX";
    private static final String SET_WITH_EXPIRE_TIME = "PX";

    /**
     * 尝试获取分布式锁
     * @param jedis Redis客户端
     * @param lockKey 锁
     * @param requestId 请求标识
     * @param expireTime 超期时间
     * @return 是否获取成功
     */
    public static boolean getLock(Jedis jedis, String lockKey, String requestId, int expireTime) {

        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);

        if (LOCK_SUCCESS.equals(result)) {
            return true;
        }
        return false;

    }

}
```



### 注意事项：

1，防止设置过期时间失败发生死锁；

```java
		Long result = jedis.setnx(lockKey, value);
    if (result == 1) {
        // 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁
        jedis.expire(lockKey, expireTime);
    }
```

变通方式，直接设置value为过期时间

```java
Long result = jedis.setnx(lockKey, expireTime);
    if (result == 1) {
        // 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁
        jedis.expire(lockKey, expireTime);
    }
//后续读取的时候判断一下时间
```

或者直接用redis事务或者直接使用lua脚本执行：

```shell
redis> MULTI            # 标记事务开始
OK
redis> SETNX job "programmer"    # job 设置成功
redis> EXPIRE job 30  # 设置过期时间为 30 秒
(integer) 1
redis> PING
QUEUED

redis> EXEC             # 执行
1) (integer) 1
4) PONG
```

2，防止非加锁端的客户端解锁；

即程序中加锁和解锁最好是在同一客户端实现，不过这可以根据具体的业务逻辑定；

### 方案图：

![](./images/20180219144927282.jpg)

### redisson第三方库：

redisson是redis官网推荐的java语言实现分布式锁的项目。当然，redisson远不止分布式锁，还包括其他一些分布式结构

https://github.com/redisson/redisson#quick-start

更复杂的方案原理：

http://ifeve.com/redis-lock/

## 数据库锁

利用数据库唯一索引加上版本号机制，外加定时任务清理



## Zookeeper

TODO

## 总结

#### 从理解的难易程度角度（从低到高）

数据库 > 缓存 > Zookeeper

#### 从实现的复杂性角度（从低到高）

Zookeeper >= 缓存 > 数据库

#### 从性能角度（从高到低）

缓存 > Zookeeper >= 数据库

#### 从可靠性角度（从高到低）

Zookeeper > 缓存 > 数据库