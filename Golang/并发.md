# 并发

## 概念：

| 概念     | 说明                           |
| ------ | ---------------------------- |
| 进程     | 一个程序对应一个独立的程序空间              |
| 线程     | 一个执行空间，一个进程可以有多个线程           |
| 逻辑处理器  | 执行创建的goroutime，绑定一个线程        |
| 调度器    | Go运行时中的,分配goroutime给不同的逻辑处理器 |
| 全局运行队列 | 所有刚创建的groutime都会放这里          |
| 本地运行队列 | 逻辑处理器的goroutime队列            |

创建goroutime-> 放入全局运行队列，->等待调度器进行调度，->分配给其中一个逻辑处理器，->放入逻辑处理器的对应的本地运行队列中 ->逻辑处理器执行

并行，是指在在不同的物理处理器上执行不同的代码块,并行可以同时做很多的事情，二并发是同时管理很多的事情。即并行利用的是计算机的cpu个数。

```Go
runtime.GOMAXPROCS(1)//设置计算机处理器个数。
//runtime.GOMAXPROCS(runtime.NumCPU())
var wg sync.WaitGroup
wg.Add(2)//开闭两个计算器 
go func(){
  defer wg.Done() //减去
  for i:=1;i<100;i++{
    fmt.Println("A:",i)
  }
}()
go func(){
  defer wg.Done()
  for i:=1;i<100;i++{
    fmt.Println("B:",i)
  }
}()
wg.Wait()//等待所以计算器完成
```

为什么要加sync.WaitGroup ，因为不加的话主线程执行完毕，程序就关闭了，加上的化，主程序会等待子程序执行完毕才关闭。

## 并发竞争：

有并发就有资源竞争，如果两个或多个goroutime在没有相互同步的情况下，访问某个共享资源，比如同时对该资源进行读写，就会处于竞争的状态，这就是并发的竞争。

```go
import "sync/atomic"
value : = atomic.LoadInt32(&count) //原子安全读取
atomic.StoreInt32(&count,value)//原子安全写入
```

核查运行，在并发下同样存在竞争问题

利用加锁可以解决：

```go
var (
	count int32
	wg    sync.WaitGroup
	mutex sync.Mutex
)

func main() {
	wg.Add(2)
	go incCount()
	go incCount()
	wg.Wait()
	fmt.Println(count)
}

func incCount() {
	defer wg.Done()
	for i := 0; i < 2; i++ {
		mutex.Lock() //加锁
		value := count
		runtime.Gosched()
		value++
		count = value
		mutex.Unlock() //解锁
	}
}
```

## 通道：

通道，类似两个routime之间架设的管道，一个routime可以往里面塞数据，另一个读取数据。类似队列。

```go
ch := make(chan int)//声明
ch <- 2 //发送数据
x := <-ch //接收数据，并赋值给x
<-ch //读取数据，然后忽略
close(ch)//关闭通道
//通道被关闭，则不能再往这个通道发送数据，如果发送会引起painc异常。但是还可以接收，没有数据返回nil
```

使用make函数初始化的，可以加第2个参数，用于指定通道的大小，默认为0，**无缓冲通道**。有对应的值，则为**有缓冲通道**。

```go
ch := make(chan int)
ch := make(chan int,0)
ch := make(chan int,2)
```

### 无缓冲通道：

又名**`同步通道`**。该类型的通道在接收钱没有能力保存任何值，要求发送和接收同时做好发送和接收准备。

```go
	ch := make(chan int)
	var sum int = 0
	go func() {
		for i := 0; i < 10; i++ {
			sum += i
		}
		ch <- sum
	}()
	<-ch
	fmt.Println(sum)//45
```

在没有ch的情况下，输出的为0，因为主线程不会等待子线程，当然也可以有，`sync.WaitGroup`来实现同步等待。这里利用同步通道，必须接收和等待同时的情况下，所以主线程会等待通道发送完数据

### 管道：

利用无缓冲通道可以实现管道操作，即一个操作输入是另外一个操作的输出

```go
	one := make(chan int)
	two := make(chan int)
	go func() {
		one <- 100
	}()
	go func() {
		two <- 100 + <-one
	}()
	fmt.Println(<-two)
```

### 有缓冲通道：

即队列，队列的最大容量就是make指定的大小。先进先出。当列队慢的时候，发送操作会阻塞，当列队空的时候，接收操作会阻塞。`cap(ch)`返回通道的最大容量，`len(ch)`返回通道里的元素个数。

```go
ch := make(chan int, 3)
ch <- 1
ch <- 2
ch <- 3
fmt.Println(<-ch) //1
fmt.Println(<-ch) //2
fmt.Println(<-ch) //3
```

最优，最快选择算法：

```Go
ch := make(chan int, 3)
var sum int = 0
//方案1
go func() {
	for i := 0; i < 10; i++ {
		sum += i
	}
	ch <- 1
}()
//方案2
go func() {
	i := 0
	for {
		if i >= 10 {
		break
	}
	sum += i
	i++
	}
	ch <- 2
}()
fmt.Println(<-ch)//输出运算最快的方案
```

### 单向通道：

有时候限制一个通道只能接收，不能发送数据，只能发送数据不能接收数据。一般用在函数或者方法参数中。

```go
var send chan<- int //只能发送数据
var rec <-chan int
```

### 读写锁：

当一个routime在写操作的时候，其他一个routime不准许写，也不准许读操作。为什么有读写锁，因为同时读操作不应该有锁，即读写锁，可以让多个读取同时并发，同时读取，但是对写操作完全是互斥的。

```go
var count int
var wg sync.WaitGroup
var rw sync.RWMutex //读写锁

func main() {
	wg.Add(10)
	for i := 0; i < 5; i++ {
		go read(i)
	}
	for i := 0; i < 5; i++ {
		go write(i)
	}
	wg.Wait()

}

func read(n int) {
	rw.RLock()
	defer rw.RUnlock()
	fmt.Printf("读取 %d ...\n", n)
	v := count
	fmt.Printf("读取 %d 完毕,值为:%d \n", n, v)
	wg.Done()
}
func write(n int) {
	rw.Lock()
	rw.Unlock()
	fmt.Printf("写%d ...\n", n)
	v := rand.Intn(100)
	count = v
	fmt.Printf("写%d 完毕,值为:%d \n", n, v)
	wg.Done()
}

```

### 什么是WaitGroup?

简单点就是全部做完，才叫做完。需要每个goroutime主动上报结束状态。

```go
	var wg sync.WaitGroup //定义一个任务组

	wg.Add(2) //定义两个任务
	go func() {
		time.Sleep(2 * time.Second)
		fmt.Println("1号任务完成")
		wg.Done() //通知完成
	}()

	go func() {
		time.Sleep(3 * time.Second)
		fmt.Println("2号任务完成")
		wg.Done()
	}()
	wg.Wait() //等待所有任务完成
	fmt.Println("全部完工了！")
```

但是有时候，我们需要在后台一直运行一个任务，如监控，当需要他停止的时候，在通知他停止。这时候就需要chan通知

### chan通知：

呈上，笨办法是，定义全局变量，通过修改变量来控制子线程任务，但是这种是不安全的。所以我们用chan+select

```go
stop := make(chan bool) //定义个无缓冲通道

	//开启监控任务
	go func() {
		for {
			select {
			case <-stop: //读取通知
				fmt.Println("监控被退出了。。。")
				return
			default:
				fmt.Println("监控进行中...")
				time.Sleep(2 * time.Second)
			}
		}
	}()

	time.Sleep(10 * time.Second)
	fmt.Println("通知停止监控！")
	stop <- true //发送通知
	time.Sleep(5 * time.Second)
```

该方法的局限在于，当很多个goroutime需要这样处理的时候，然后goroutime又衍生出其他的时候，就会很乱很复杂。

### Context上下文:

```go
func main() {
	//定义一个根上下文 并附带cancel方法
	ctx, cancel := context.WithCancel(context.Background())

	go func(ctx context.Context) {
		for {
			select {
			case <-ctx.Done(): //判断是否停止
				fmt.Println("监控被停止了...")
				return
			default:
				fmt.Println("监控进行中...")
				time.Sleep(2 * time.Second)
			}
		}
	}(ctx)
	time.Sleep(10 * time.Second)
	fmt.Println("停止监控...")
	cancel() //执行上下文的cancel方法
	time.Sleep(5 * time.Second)
}
```

Context.Background() 返回一个空的Context，空的Context一般用于整个Context的根节点。context.WithCancel(parent)函数，创建一一个可以取消的子Context

```go
func main() {
	ctx, can := context.WithCancel(context.Background())
	go watch(ctx, "【1号】")
	go watch(ctx, "【2号】")
	go watch(ctx, "【3号】")

	time.Sleep(10 * time.Second)
	fmt.Println("停止所有....")
	can()

	time.Sleep(5 * time.Second)
}
func watch(ctx context.Context, name string) {
	for {
		select {
		case <-ctx.Done():
			fmt.Println(name, "监控停止了...")
			return
		default:
			fmt.Println(name, "监控中...")
			time.Sleep(2 * time.Second)
		}
	}
}
```

#### Context接口

```go
type Context interface {
  	//获取设置的截止时间，到该截止时间会自动取消
	Deadline() (deadline time.Time, ok bool)
	Done() <-chan struct{}
	Err() error
	Value(key interface{}) interface{}
}

//生成一个空ctx
var (
	background = new(emptyCtx)
	todo       = new(emptyCtx)
)
func Background() Context {
	return background
}
func TODO() Context {
	return todo
}


//传递一个父ctx,返回一个子ctx 和一个取消函数
func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
//同WithCancel 只是会多传递一个截止时间参数，在指定时间内自动取消
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
//生成一个帮的键值对的数据的Context
func WithValue(parent Context, key, val interface{}) Context
```

#### Context使用原则：

1. 不要把Context放在结构体中，要以参数的方式传递
2. 以Context作为参数的函数方法，应该把Context作为第一个参数，放在第一位。
3. 给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO
4. Context的Value相关方法应该传递必须的数据，不要什么数据都使用这个传递
5. Context是线程安全的，可以放心的在多个goroutine中传递



```go
var k1 string = "name"

func main() {
	ctx, can := context.WithCancel(context.Background())

	valCtx := context.WithValue(ctx, k1, "【监控】")

	go func(ctx context.Context) {
		ctx1, _ := context.WithTimeout(ctx, 3*time.Second)
		//新启动另外一个
		go watch(ctx1, "【1号子监控】")

		watch(ctx, "【1号监控】")
	}(valCtx)

	go watch(valCtx, "【2号监控】")

	go watch(valCtx, "【3号监控】")

	time.Sleep(10 * time.Second)
	fmt.Println("停止所有....")
	can()

	time.Sleep(5 * time.Second)
}
func watch(ctx context.Context, name string) {
	for {
		select {
		case <-ctx.Done():
			fmt.Println(name, "监控停止了...")
			return
		default:
			fmt.Println(name, "监控中...", ctx.Value(k1))
			time.Sleep(1 * time.Second)
		}
	}
}

```