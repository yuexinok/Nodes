# 并发

## 概念：

| 概念     | 说明                           |
| ------ | ---------------------------- |
| 进程     | 一个程序对应一个独立的程序空间              |
| 线程     | 一个执行空间，一个进程可以有多个线程           |
| 逻辑处理器  | 执行创建的goroutime，绑定一个线程        |
| 调度器    | Go运行时中的,分配goroutime给不同的逻辑处理器 |
| 全局运行队列 | 所有刚创建的groutime都会放这里          |
| 本地运行队列 | 逻辑处理器的goroutime队列            |

创建goroutime-> 放入全局运行队列，->等待调度器进行调度，->分配给其中一个逻辑处理器，->放入逻辑处理器的对应的本地运行队列中 ->逻辑处理器执行

并行，是指在在不同的物理处理器上执行不同的代码块,并行可以同时做很多的事情，二并发是同时管理很多的事情。即并行利用的是计算机的cpu个数。

```Go
runtime.GOMAXPROCS(1)//设置计算机处理器个数。
//runtime.GOMAXPROCS(runtime.NumCPU())
var wg sync.WaitGroup
wg.Add(2)//开闭两个计算器 
go func(){
  defer wg.Done() //减去
  for i:=1;i<100;i++{
    fmt.Println("A:",i)
  }
}()
go func(){
  defer wg.Done()
  for i:=1;i<100;i++{
    fmt.Println("B:",i)
  }
}()
wg.Wait()//等待所以计算器完成
```

为什么要加sync.WaitGroup ，因为不加的话主线程执行完毕，程序就关闭了，加上的化，主程序会等待子程序执行完毕才关闭。

## 并发竞争：

有并发就有资源竞争，如果两个或多个goroutime在没有相互同步的情况下，访问某个共享资源，比如同时对该资源进行读写，就会处于竞争的状态，这就是并发的竞争。

```go
import "sync/atomic"
value : = atomic.LoadInt32(&count) //原子安全读取
atomic.StoreInt32(&count,value)//原子安全写入
```

核查运行，在并发下同样存在竞争问题

利用加锁可以解决：

```go
var (
	count int32
	wg    sync.WaitGroup
	mutex sync.Mutex
)

func main() {
	wg.Add(2)
	go incCount()
	go incCount()
	wg.Wait()
	fmt.Println(count)
}

func incCount() {
	defer wg.Done()
	for i := 0; i < 2; i++ {
		mutex.Lock() //加锁
		value := count
		runtime.Gosched()
		value++
		count = value
		mutex.Unlock() //解锁
	}
}
```

## 通道：

通道，类似两个routime之间架设的管道，一个routime可以往里面塞数据，另一个读取数据。类似队列。

```go
ch := make(chan int)//声明
ch <- 2 //发送数据
x := <-ch //接收数据，并赋值给x
<-ch //读取数据，然后忽略
close(ch)//关闭通道
//通道被关闭，则不能再往这个通道发送数据，如果发送会引起painc异常。但是还可以接收，没有数据返回nil
```

使用make函数初始化的，可以加第2个参数，用于指定通道的大小，默认为0，**无缓冲通道**。有对应的值，则为**有缓冲通道**。

```go
ch := make(chan int)
ch := make(chan int,0)
ch := make(chan int,2)
```

### 无缓冲通道：

又名**`同步通道`**。该类型的通道在接收钱没有能力保存任何值，要求发送和接收同时做好发送和接收准备。

```go
	ch := make(chan int)
	var sum int = 0
	go func() {
		for i := 0; i < 10; i++ {
			sum += i
		}
		ch <- sum
	}()
	<-ch
	fmt.Println(sum)//45
```

在没有ch的情况下，输出的为0，因为主线程不会等待子线程，当然也可以有，`sync.WaitGroup`来实现同步等待。这里利用同步通道，必须接收和等待同时的情况下，所以主线程会等待通道发送完数据

### 管道：

利用无缓冲通道可以实现管道操作，即一个操作输入是另外一个操作的输出

```go
	one := make(chan int)
	two := make(chan int)
	go func() {
		one <- 100
	}()
	go func() {
		two <- 100 + <-one
	}()
	fmt.Println(<-two)
```

### 有缓冲通道：

即队列，队列的最大容量就是make指定的大小。先进先出。当列队慢的时候，发送操作会阻塞，当列队空的时候，接收操作会阻塞。`cap(ch)`返回通道的最大容量，`len(ch)`返回通道里的元素个数。

```go
ch := make(chan int, 3)
ch <- 1
ch <- 2
ch <- 3
fmt.Println(<-ch) //1
fmt.Println(<-ch) //2
fmt.Println(<-ch) //3
```

最优，最快选择算法：

```Go
ch := make(chan int, 3)
var sum int = 0
//方案1
go func() {
	for i := 0; i < 10; i++ {
		sum += i
	}
	ch <- 1
}()
//方案2
go func() {
	i := 0
	for {
		if i >= 10 {
		break
	}
	sum += i
	i++
	}
	ch <- 2
}()
fmt.Println(<-ch)//输出运算最快的方案
```

### 单向通道：

有时候限制一个通道只能接收，不能发送数据，只能发送数据不能接收数据。一般用在函数或者方法参数中。

```go
var send chan<- int //只能发送数据
var rec <-chan int
```

### 读写锁：

当一个routime在写操作的时候，其他一个routime不准许写，也不准许读操作。为什么有读写锁，因为同时读操作不应该有锁，即读写锁，可以让多个读取同时并发，同时读取，但是对写操作完全是互斥的。

```go
var count int
var wg sync.WaitGroup
var rw sync.RWMutex //读写锁

func main() {
	wg.Add(10)
	for i := 0; i < 5; i++ {
		go read(i)
	}
	for i := 0; i < 5; i++ {
		go write(i)
	}
	wg.Wait()

}

func read(n int) {
	rw.RLock()
	defer rw.RUnlock()
	fmt.Printf("读取 %d ...\n", n)
	v := count
	fmt.Printf("读取 %d 完毕,值为:%d \n", n, v)
	wg.Done()
}
func write(n int) {
	rw.Lock()
	rw.Unlock()
	fmt.Printf("写%d ...\n", n)
	v := rand.Intn(100)
	count = v
	fmt.Printf("写%d 完毕,值为:%d \n", n, v)
	wg.Done()
}

```

